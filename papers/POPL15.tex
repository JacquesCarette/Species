%% -*- mode: LaTeX; compile-command: "mk" -*-

\documentclass[preprint,authoryear]{sigplanconf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Package imports

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage[all]{xy}
\usepackage{breakurl}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Diagrams

\usepackage{graphicx}
\usepackage[outputdir=diagrams,backend=cairo,extension=pdf]{diagrams-latex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prettyref

\usepackage{prettyref}

\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{sec}{\Sect\ref{#1}}
\newrefformat{eq}{equation~\eqref{#1}}
\newrefformat{prob}{Problem~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{thm}{Theorem~\ref{#1}}
\newrefformat{lem}{Lemma~\ref{#1}}
\newrefformat{prop}{Proposition~\ref{#1}}
\newrefformat{defn}{Definition~\ref{#1}}
\newrefformat{cor}{Corollary~\ref{#1}}
\newcommand{\pref}[1]{\prettyref{#1}}

% \Pref is just like \pref but it uppercases the first letter; for use
% at the beginning of a sentence.
\newcommand{\Pref}[1]{%
  \expandafter\ifx\csname r@@#1\endcsname\relax {\scriptsize[ref]}
    \else
    \edef\reftext{\prettyref{#1}}\expandafter\MakeUppercase\reftext
    \fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Comments

\newif\ifcomments\commentstrue
%\newif\ifcomments\commentsfalse

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\newcommand{\chaptertodo}[1]{\textcolor{gray}{[TODO (Later): #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\newcommand{\chaptertodo}[1]{}
\fi

\newcommand{\bay}[1]{\authornote{blue}{BAY}{#1}}
\newcommand{\jc}[1]{\authornote{purple}{JC}{#1}}
\newcommand{\scw}[1]{\authornote{magenta}{SCW}{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Semantic markup

\newcommand{\eg}{\latin{e.g.}\xspace}
\newcommand{\ie}{\latin{i.e.}\xspace}
\newcommand{\etal}{\latin{et al.}\xspace}
\newcommand{\etc}{\latin{etc.}\xspace}

\newcommand{\term}[1]{\emph{#1}}
\newcommand{\latin}[1]{\textit{#1}}
\newcommand{\foreign}[1]{\emph{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Misc

\newcommand{\LUO}{$\Lambda$\kern -.1667em\lower .5ex\hbox{$\Upsilon$}\kern -.05em\raise .3ex\hbox{$\Omega$}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Math typesetting

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% General math

\newcommand{\bbb}[1]{\ensuremath{\mathbb{#1}}\xspace}
\providecommand{\N}{\bbb{N}}
\providecommand{\Z}{\bbb{Z}}
\providecommand{\Q}{\bbb{Q}}
\providecommand{\R}{\bbb{R}}
\providecommand{\C}{\bbb{C}}

\newcommand{\mcal}[1]{\ensuremath{\mathcal{#1}}}
\let\Sect\S
\renewcommand{\S}{\mcal S}
\renewcommand{\H}{\mcal H}
\newcommand{\I}{\mcal I}
\newcommand{\Sym}{\mcal S}

\newcommand{\msf}[1]{\ensuremath{\mathsf{#1}}\xspace}
\newcommand{\newmsf}[1]{%
\expandafter\providecommand\csname #1\endcsname{}\expandafter\renewcommand\csname #1\endcsname{\msf{#1}}}

\newcommand{\param}{\mathord{-}}

\newcommand{\comp}{\mathbin{\circ}}
\newcommand{\union}{\cup}
\newcommand{\Union}{\bigcup}
\newcommand{\intersect}{\cap}
\newcommand{\Intersect}{\bigcap}

\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}

\newcommand{\bij}{\stackrel{\sim}{\longrightarrow}}
\newcommand{\perm}[1]{#1!}
\newcommand{\mkIso}{\rightleftharpoons}
\newcommand{\inj}{\hookrightarrow}
\let\oldequiv\equiv
\newcommand{\jeq}{\oldequiv}          % judgmental equality
\newcommand{\defeq}{\mathrel{:\jeq}}  % definitional equality
\renewcommand{\equiv}{\simeq}         % homotopy equivalence
\newcommand{\iso}{\cong}              % isomorphism in a category

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Theorems etc.

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{ex}{Example}
\newtheorem*{nota}{Notation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type theory

\newcommand{\universe}{\mcal{U}}
\newcommand{\dep}[1]{\prod_{#1}}
\newcommand{\fun}[1]{\lambda #1.\ }

\newcommand{\TyZero}{\ensuremath{\bot}\xspace}
\newcommand{\TyOne}{\ensuremath{\top}\xspace}
\newcommand{\unit}{\ensuremath{\star}\xspace}

\newcommand{\cons}[1]{\ensuremath{\mathsf{#1}}}

\providecommand{\False}{}
\renewcommand{\False}{\cons{F}}
\providecommand{\True}{}
\renewcommand{\True}{\cons{T}}

\newcommand{\zero}{\msf{O}}
\newcommand{\suc}[1]{\msf{S}\ #1}
\newcommand{\fzero}{\msf{FO}}
\newcommand{\fsuc}{\msf{FS}}

\newcommand{\lam}[2]{\lambda\,#1.\;#2}

\newcommand{\pair}[2]{\langle #1 , #2 \rangle}
\newcommand{\inl}{\cons{inl}}
\newcommand{\inr}{\cons{inr}}
\newcommand{\outl}{\cons{outl}}
\newcommand{\outr}{\cons{outr}}

\newcommand{\Type}{\ensuremath{\mathcal{U}}}
\newcommand{\FinType}{\ensuremath{\Type_{\text{Fin}}}}
\newcommand{\FinTypeT}{\ensuremath{\Type_{\ptrunc{\text{Fin}}}}}
\newcommand{\IsFinite}[1]{\mathsf{IsFinite}\;#1}
\newcommand{\sizesymb}{\#}
\newcommand{\size}[1]{\ensuremath{\sizesymb#1}}

\newcommand{\Fin}[1]{\ensuremath{\cons{Fin}\ #1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HoTT

\newcommand{\ptrunc}[1]{\ensuremath{\left\||#1\right\||}}
\newcommand{\id}{\cons{id}}

\newcommand{\tygrpd}[1]{\ensuremath{\mathbf{G}(#1)}}

\newcommand{\transport}[2]{\ensuremath{\mathsf{transport}^{#1}(#2)}}

\newmsf{ua}

\newcommand{\hott}[1]{\textit{h}-#1}

\newmsf{isSet}
\newmsf{isFinite}

\newmsf{Fun}
\newmsf{Ana}

\newcommand{\homsymb}{\Rightarrow}
\providecommand{\hom}{}
\renewcommand{\hom}[3][]{#2 \homsymb_{#1} #3}

\newcommand{\CT}{\mcal{C}}
\newcommand{\DT}{\mcal{D}}
\newcommand{\ST}{\mcal{S}}
\newcommand{\SetT}{\msf{Set}}
\newcommand{\idT}{\msf{id}}

\newmsf{idtoiso}
\newmsf{isotoid}
\newmsf{qinv}
\newmsf{isequiv}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Category theory

% typesetting for category names
\newcommand{\cat}[1]{\ensuremath{\mathbf{#1}}\xspace}

\newcommand{\op}{\ensuremath{\mathrm{op}}}            % opposite category
\newcommand{\disc}[1]{\ensuremath{\left||#1\right||}} % discrete category
\newcommand{\then}{\mathbin{;}}                       % flipped composition

% morphisms
\newcommand{\mor}[2]{\ensuremath{#1 \longrightarrow #2}}
\newcommand{\nat}[2]{\ensuremath{#1 \stackrel{\bullet}{\longrightarrow} #2}}

% some standard categories
\newcommand{\Set}{\cat{Set}}

\providecommand{\B}{\bbb{B}}
\renewcommand{\P}{\bbb{P}}
\providecommand{\FinSet}{\bbb{E}}

\newcommand{\BT}{\mcal{B}}
\newcommand{\PT}{\mcal{P}}

\newcommand{\fin}[1]{\ensuremath{[#1]}}

% monoidal lifting
\newcommand{\lifted}[1]{\hat{#1}}
\newcommand{\lotimes}{\mathbin{\lifted{\otimes}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Species

\providecommand{\Sp}{}
\renewcommand{\Sp}{\msf}
\newcommand{\X}{\Sp{X}}
\newcommand{\Y}{\Sp{Y}}
\newcommand{\E}{\Sp{E}}
\newcommand{\F}{\Sp{F}}
\newcommand{\G}{\Sp{G}}
\renewcommand{\L}{\Sp{L}}
\newcommand{\T}{\Sp{T}}
\newcommand{\Par}{\Sp{Par}}
\newcommand{\Bag}{\Sp{E}}
\newcommand{\Cyc}{\Sp{C}}

\newcommand{\Zero}{\msf{0}}
\newcommand{\One}{\msf{1}}

\newcommand{\sprod}{\cdot}
\newcommand{\fcomp}{\mathbin{\square}}

\providecommand{\comp}{\circ}

\newcommand{\usum}{\boxplus}
\newcommand{\uprod}{\boxtimes}
\newcommand{\ucomp}{\boxcircle}

\newcommand{\unl}[1]{\widetilde{#1}}

\newcommand{\Lab}{\bbb{L}}
\newcommand{\Str}{\bbb{S}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{POPL '15}{January 11--18, 2015, Mumbai, India}
\copyrightyear{2015}
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
%\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the
% traditional copyright transfer agreement.

\exclusivelicense                % ACM gets exclusive license to publish,
                                 % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers,
                                  % short abstracts)

\titlebanner{DRAFT --- do not distribute}        % These are ignored unless
\preprintfooter{Submitted to POPL'15}   % 'preprint' option specified.

\title{Type-Theoretic Foundations for Combinatorial Species}
%\subtitle{Subtitle Text, if any}

\authorinfo{Brent A. Yorgey \\ Stephanie Weirich}
{Dept. of Computer and Information Science\\ The University of Pennsylvania\\
Philadelphia, Pennsylvania, USA}
{\{byorgey,sweirich\}@cis.upenn.edu}

\authorinfo{Jacques Carette}
{Dept. of Computing and Software\\ McMaster University\\
Hamilton, Ontario, Canada}
{carette@mcmaster.ca}

\maketitle

\begin{abstract}
  This paper develops a constructive definition of Joyal's theory of
  combinatorial species within homotopy type theory. \todo{We
    first\dots finiteness etc\dots}
  We justify our definitions
  by generalizing various operations on species to arbitrary functor
  categories. In particular, we lift monoidal structures from the codomain
  category to define species sum and
  Cartesian product, and Day convolution to push monoidal structures from
  the domain category to define partitional and arithmetic
  products. This foundational work is the first step in the application of the
  theory of species to a wide class of data structures.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
% \terms
% term1, term2

\keywords
Combinatorial Species, Homotopy Type Theory

\section{Introduction}
\label{sec:intro}

The theory of \emph{combinatorial species} is was first set forth by
Joyal~\cite{joyal} as a system for understanding and unifying much of
\emph{enumerative combinatorics}, the branch of mathematics concerned
with counting abstract structures. Accordingly, this theory provides a
unified view of structures, presenting them in a general,
compositional framework.  Furthermore, there seems to be a connection
between this framework of abstract structures and the data structures
that programmers use. We can think of these structures as some sort of
``shape'' containing \emph{labeled positions} or
\emph{locations}. When paired with a mapping from those labels to
actual data, species can be used to model familiar data
structures---as well as unfamiliar ones. We would like to use this
beautiful theory to enrich and expand our understanding of data
structures.

However, teasing out the precise relationship between species and data
structures has proved challenging, for two reasons. First, combinatorialists
are mainly concerned with enumerating and generating abstract structures, not
with storing and computing with data.  Thus, in order to apply this theory in
a computational setting, there are hidden assumptions and glossed
distinctions that must first be made explicit.  Second, being situated in
traditional mathematical practice rooted in set theory,
% \footnote{notwithstanding the fact that the foundational work is
%   categorical},
species are described in ways that are \emph{untyped} and
\emph{nonconstructive}, both of which hinder adoption and understanding in a
computational context.

In this paper, we create a bridge between the theory of species and the theory
and practice of programming. In particular, we ``port'' the definition of
combinatorial species to a constructive type theory, making the theory more
directly applicable in a programming context and more accessible to functional
programmers.

This port is nontrivial. In fact, it took us several tries to get definitions
that worked adequately. Part of the difficulty lies in the fact that
species are defined over \emph{finite} sets of labels.  In a classical
setting, while finiteness is a crucial part of the definition, it is an
otherwise fairly implicit feature of the actual theory.  Combinatorialists do
not need to remind themselves of this finiteness condition, as it is a
pervasive axiom that you can only ``count'' finite collections of objects.
When ported to a constructive setting, however, the notion of finiteness takes
on nontrivial computational content and significance.  In particular, we are
naturally led to work up to computationally relevant \emph{equivalences} on
labels.  Therefore, the constructive type theory that we work in is
\emph{homotopy type theory} (HoTT) \cite{hottbook}, a theory that can naturally
express these computationally relevant equivalences.

More specifically, the contributions of this paper are:

\begin{itemize}
\item We define the concept of \emph{species} in
  constructive type theory (\pref{sec:constructive-species}).% , characterizing
  % them as functors from a finite collection of labels to structures.
\item We find a suitable definition of \emph{finiteness} consistent with HoTT
  and species.
\item As part of our port to type theory, we generalize common operations on
  species, including sum, partitional and Cartesian product,
  carefully analyzing their requirements to ensure consistency
  with our new interpretation.
% remove 'arithmetic product' from this list since it is far from 'common'!
\item This generalization leads to new insights. In particular, we observe
  that arithmetic product arises from Day convolution (\pref{sec:day}).
\end{itemize}

In the next section, we review the set-theoretic definitions of species (\pref{sec:species}),
before recasting them in the context of homotopy type theory in
\pref{sec:prelim}.  We assume familiarity with dependent type theory and
(basic) category throughout, but will spell out the basic HoTT tools
we need, as well as more advanced categorical constructions.

\section{Species in set theory}
\label{sec:species}

Species, intuitively, are \emph{families of labelled shapes}---shapes
that are \emph{indexed by} sets of labels.  For example, the species
$\L$ of \emph{lists} (or \emph{linear orderings}) sends every set of
labels (of size $n$) to the set of all sequences (of size $n!$)
containing each label exactly once.  Similarly, the species of
\emph{binary trees} sends every set of labels to the set of all binary
trees built over those labels.  Other species describe non-algebraic
data structures, such as cycles, bags and permutations.

\begin{defn}[Species (Joyal \cite{joyal,bll})]
\label{defn:species-set}
A \term{species} $F$ is a pair of mappings which sends any finite set
$U$ (of \term{labels}) to a set $F\ U$ (of \term{shapes}), and sends
any bijection%
\footnote{We use the notation $U \bij V$ for the type of bijections
  between sets $U$ and $V$.} $\sigma : U \bij V$ to a function $F\
\sigma : F\ U \to F\ V$
%  (illustrated in \pref{fig:relabeling}),
satisfying functoriality conditions:
$F\ id_U = id_{F U}$, and
$F (\sigma \circ \tau) = F\ \sigma \circ F\ \tau$.
%\begin{itemize}
%\item $F\ id_U = id_{F U}$, and
%\item $F (\sigma \circ \tau) = F\ \sigma \circ F\ \tau$.
%\end{itemize}
\end{defn}

We call $F\ U$ the set of ``\mbox{$F$-shapes} with labels drawn from $U$'',
or simply ``\mbox{$F$-shapes} on $U$'', or even (when $U$ is clear from
context) just ``\mbox{$F$-shapes}''.\footnote{Margaret Readdy's English translation
  of Bergeron \etal \cite{bll} uses the word ``structure'' instead of
  ``shape'', but that word is likely to remind computer scientists of
  ``data structures'', which is the wrong association: data structures
  contain \emph{data}, whereas species shapes do not.  We choose the
  word ``shape'' to emphasize the fact that they are ``form without
  content''.} The bijection $\sigma$ is called a ``relabeling'', and $F\ \sigma$ is called the ``transport of $\sigma$ along
$F$'', or sometimes the ``relabeling of \mbox{$F$-shapes} by $\sigma$''.

The functoriality of relabeling means that the actual labels used
don't matter; we get ``the same shapes'' up to relabeling for any
label sets of the same size.  In other words, $F$'s action on all
label sets of size $n$ is determined by its action on any particular
such set. Therefore, we often take the finite set of natural numbers $[n] = \{0,
\dots, n-1\}$ as \emph{the} canonical label set of size $n$, and write
$F\ n$ for the set of $F$-shapes built from this set.

Using categorical language, an equivalent, more
concise definition of species is:
\begin{defn}
  \label{defn:species-cat}
  A \term{species} is a functor $F : \B \to \Set$, where $\B$ is the
  groupoid of finite sets and bijections,\footnote{$\B$ for
    \emph{bijection}, a rare category named for its arrows.}  and
  $\Set$ is the category of sets and (total) functions.
\end{defn}

\begin{rem}
  Although these definitions say only that a species $F$ sends a bijection
  $\sigma : U \bij V$ to a \emph{function} $F\ \sigma : F\ U \to F\
  V$, the functoriality of $F$ guarantees that $F\ \sigma$
  will always be a bijection as well.
\end{rem}

Porting the theory of species to a constructive setting
requires defining categories $\BT$ and $\ST$ so that a functor $\BT \to
\ST$ is a ``constructive counterpart'' to $\B \to \Set$.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{POPL15}

% The bibliography should be embedded for final submission.

% \begin{thebibliography}{}
% \softraggedright

% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...

% \end{thebibliography}


\end{document}
