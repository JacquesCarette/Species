\documentclass[9pt]{sigplanconf}

\usepackage{../species}

%\usepackage{latex8}
%\usepackage{times}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{proof}
\usepackage{comment}
\usepackage{url}
\usepackage{xspace}
\usepackage{xcolor}

\pdfpagewidth=8.5in
\pdfpageheight=11in

\newcommand{\lam}[2]{\lambda #1 . #2}

\newcommand{\rase}[1]{\ulcorner #1 \urcorner}
\newcommand{\lowr}[1]{\llcorner #1 \lrcorner}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prettyref

\usepackage{prettyref}

\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{sec}{section~\ref{#1}}
\newrefformat{eq}{equation~\eqref{#1}}
\newrefformat{prob}{Problem~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{thm}{Theorem~\ref{#1}}
\newrefformat{lem}{Lemma~\ref{#1}}
\newrefformat{prop}{Proposition~\ref{#1}}
\newrefformat{defn}{Definition~\ref{#1}}
\newrefformat{cor}{Corollary~\ref{#1}}
\newcommand{\pref}[1]{\prettyref{#1}}

% \Pref is just like \pref but it uppercases the first letter; for use
% at the beginning of a sentence.
\newcommand{\Pref}[1]{%
  \expandafter\ifx\csname r@#1\endcsname\relax {\scriptsize[ref]}
    \else
    \edef\reftext{\prettyref{#1}}\expandafter\MakeUppercase\reftext
    \fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Comments

\specialcomment{bay}{\begingroup[\color{blue}}{ --- BAY\endgroup]}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Misc

\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\ie}{\emph{i.e.}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Towards Typing for Small-Step Direct Reflection}

\authorinfo{Jacques Carette}
{Dept. of Computing and Software\\ McMaster University\\
Hamilton, Ontario, Canada}
{carette@mcmaster.ca}

\authorinfo{Brent A. Yorgey}
{Dept. of Computer and Information Science\\ The University of Pennsylvania\\
Philadelphia, Pennsylvania, USA}
{byorgey@cis.upenn.edu}

\maketitle

\begin{abstract}
\end{abstract}

\category{D.3.2}{Programming Languages}{Applicative (functional) languages}
\category{F.3.1}{Logics and Meanings of Programs}{Specifying and Verifying and Reasoning about Programs}

\terms
Languages, Types

\section{Introduction}\label{sec:intro}

\section{Species as semantics}\label{sec:specsem}
\begin{itemize}
\item brief recap of definition of species, categorically
\item short intro to operators on species
\item implicit species theorem
\end{itemize}

\section{A language of type constructors based on species}\label{sec:language}
\begin{itemize}
\item need declaration language, based on above
\end{itemize}

We begin with a simple universe of \emph{species expressions}, defined
as in~\pref{fig:universe}.  Starting with \emph{syntax} in this way is
certainly uncontroversial in a computer science context, but
represents something of a departure from the standard literature on
species.

\begin{figure}
  \centering
  \begin{align*}
    S & ::= \Zero \\
    & \mid \X^n/\H_n & n \in \N, \H_n \subseteq \S_n \\
    & \mid S \usum S \\
    & \mid S \uprod S \\
    & \mid S \ucomp S
  \end{align*}
  \caption{The universe of species expressions}
  \label{fig:universe}
\end{figure}

\begin{itemize}
\item $\Zero$ represents the usual zero species.

\item $\X^n/\H_n$ represents a molecular species, in particular the
  species whose structures are equivalence classes of linear orderings
  of $n$ labels under the action of the permutation group $\H_n$.

\item $S_1 \uplus S_2$ denotes the usual species sum (\ie tagged
  union), $S_1 \uprod S_2$ denotes the usual (partitional) product of
  species, and $S_1 \ucomp S_2$ the usual (partitional) composition of
  species.
\end{itemize}

For convenience, we also use some abbreviations:
\begin{itemize}
\item $\One$ denotes $\X^0 / \I_0$, the usual unit species (where
  $\I_n$ denotes the trivial group of permutations on $n$ elements).
\item $\X$ denotes $\X^1 / \I_1$, the usual identity species.
\end{itemize}

\begin{bay}
  I guess we also need to include special cases for things like \E\
  and \C\ in the universe?
\end{bay}

\section{Programming with species, part I}\label{sec:prog1}
\begin{itemize}
\item basic term language (introduction, elimination forms)
\item semantics, and usual theorems
\end{itemize}

\section{Programming with species, part II}\label{sec:prog2}
\begin{itemize}
\item polytypic/generic programming (includes map, fold, unfold, etc.)
\end{itemize}

\section{Species and Haskell}\label{sec:haskell}
\begin{itemize}
\item why the implicit species theorem's assumptions are always satisfied in Haskell (but not in traditional type theories)
\end{itemize}

\section{Related Work}\label{sec:related}
\begin{itemize}
\item containers, naturally
\end{itemize}

\section{Conclusion}\label{sec:conclusion}

%\bibliographystyle{plainnat}
%\bibliography{paper}

\end{document}
